<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hand Draw — Pinch to Draw</title>
  <style>
    :root {
      --panel-bg: rgba(0,0,0,0.6);
      --accent: #2dd4bf;
      --muted: #9fb3d8;
      --fg: #e6eef8;
    }

    html,body {
      height: 100%;
      margin: 0;
      background: #000;
      color: var(--fg);
      font-family: Inter, system-ui, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    .wrap {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 18px;
    }

    header { font-weight:700; font-size:20px; }

    .stage {
      position: relative;
      width: 86vw;
      max-width: 1000px;
      border-radius: 12px;
      overflow: hidden;
      background: #000;
      box-shadow: 0 6px 20px rgba(0,0,0,0.6);
    }

    canvas { display:block; width:100%; height:auto; }
    #drawCanvas { position: relative; z-index: 1; background: black; }
    #overlayCanvas { position:absolute; top:0; left:0; z-index:2; pointer-events:none; background: transparent; }

    .controls {
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
      justify-content:center;
      padding:10px;
      background:var(--panel-bg);
      border-radius:10px;
    }

    .controls .group { display:flex; gap:8px; align-items:center; }
    .controls label { display:flex; gap:6px; align-items:center; font-size:13px; color:var(--muted); }
    .controls input[type=color] { width:36px; height:28px; padding:0; border:0; background:none; }
    .controls input[type=range] { width:140px; }
    .controls button { background:transparent; border:1px solid rgba(255,255,255,0.08); padding:6px 10px; border-radius:8px; color:var(--fg); cursor:pointer; }
    .controls button.primary { border-color: var(--accent); box-shadow:0 4px 14px rgba(45,212,191,0.06); }

    .small { font-size:12px; color:var(--muted); }
    #status { font-size:13px; color:var(--muted); margin-top:6px; }
    footer { font-size:12px; color:var(--muted); opacity:0.9; margin-top:6px; }

    .overlay-backdrop { position:fixed; inset:0; background:linear-gradient(rgba(0,0,0,0.6),rgba(0,0,0,0.6)); display:flex; align-items:center; justify-content:center; z-index:999; }
    .tutorial { background:#06121a; border:1px solid rgba(255,255,255,0.06); padding:18px; border-radius:12px; max-width:520px; color:var(--fg); box-shadow:0 12px 40px rgba(0,0,0,0.7); }
    .tutorial h2 { margin:0 0 8px 0; }
    .tutorial p { margin:6px 0; color:#bcd7f0; }
    .tutorial .cta { display:flex; gap:8px; justify-content:flex-end; margin-top:12px; }
    .hidden { display:none; }

    @media (max-width:700px) { .controls { flex-direction:column; gap:6px; } }
  </style>
</head>
<body>
  <div class="wrap">
    <header>Hand Draw — pinch to draw</header>

    <div class="stage" id="stage">
      <video id="video" autoplay playsinline muted style="display:none"></video>
      <canvas id="drawCanvas"></canvas>
      <canvas id="overlayCanvas" aria-hidden="true"></canvas>
    </div>
    <div class="controls" role="toolbar" aria-label="drawing controls">
      <div class="group">
        <button id="startCamBtn" class="primary" title="Start camera (required for hand tracking)">Start Camera</button>
        <button id="stopCamBtn" disabled title="Stop camera">Stop</button>
        <button id="localDrawBtn" title="Toggle local pointer drawing">Local Draw: Off</button>
      </div>

      <div class="group">
        <label>Color <input id="colorPicker" type="color" value="#ff3b30"></label>
        <label>Size <input id="sizeRange" type="range" min="1" max="80" value="8"></label>
      </div>

      <div class="group">
        <label>Pinch Sens. <input id="pinchRange" type="range" min="2" max="12" step="1" value="5" title="Lower is easier to trigger"></label>
        <label>Smoothing <input id="smoothingRange" type="range" min="0" max="90" step="5" value="30" title="Higher = smoother"></label>
      </div>

      <div class="group">
        <label><input id="adaptiveWidth" type="checkbox"> Adaptive width</label>
        <label><input id="showLandmarks" type="checkbox" checked> Show landmarks</label>
        <button id="undoBtn" title="Undo last action">Undo</button>
        <button id="saveBtn" title="Save PNG">Save</button>
        <button id="calibrateBtn" title="Auto-calibrate pinch">Auto Calibrate</button>
        <button id="clearBtn" title="Clear canvas">Clear</button>
      </div>
    </div>

    <div id="status" class="small">Idle — click Start Camera or Local Draw.</div>
    <footer>Tip: Serve over https or http://localhost. Allow camera when asked. Use good lighting.</footer>
  </div>

  <div id="tutorialOverlay" class="overlay-backdrop hidden" role="dialog" aria-modal="true">
    <div class="tutorial" role="document">
      <h2>Welcome to Hand Draw</h2>
      <p>Use pinch-to-draw: bring thumb + index together to draw. Use Local Draw to draw with mouse/touch.</p>
      <p>Adjust Pinch Sens. and Smoothing to tune responsiveness. Use Save to export your strokes (no overlays).</p>
      <div class="cta">
        <button id="dismissTutorial">Got it</button>
        <button id="dontShowTutorial">Don't show again</button>
      </div>
    </div>
  </div>
  <!-- MediaPipe libraries -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <script>
  const video = document.getElementById('video');
  const drawCanvas = document.getElementById('drawCanvas');
  const overlayCanvas = document.getElementById('overlayCanvas');
  const drawCtx = drawCanvas.getContext('2d');
  const overlayCtx = overlayCanvas.getContext('2d');

  const startCamBtn = document.getElementById('startCamBtn');
  const stopCamBtn = document.getElementById('stopCamBtn');
  const localDrawBtn = document.getElementById('localDrawBtn');
  const colorPicker = document.getElementById('colorPicker');
  const sizeRange = document.getElementById('sizeRange');
  const pinchRange = document.getElementById('pinchRange');
  const smoothingRange = document.getElementById('smoothingRange');
  const adaptiveWidth = document.getElementById('adaptiveWidth');
  const showLandmarks = document.getElementById('showLandmarks');
  const undoBtn = document.getElementById('undoBtn');
  const saveBtn = document.getElementById('saveBtn');
  const calibrateBtn = document.getElementById('calibrateBtn');
  const clearBtn = document.getElementById('clearBtn');
  const statusEl = document.getElementById('status');

  let localDraw = false;
  let cameraInstance = null;
  let isDrawing = false;
  let lastX = null, lastY = null;
  let smoothedLandmarks = null;
  let wasPinching = false;
  let pinchThresholdNorm = parseInt(pinchRange.value) / 100;
  const undoStack = [];
  const MAX_UNDO = 30;

  function resizeCanvases(cssW, cssH) {
    const dpr = window.devicePixelRatio || 1;
    drawCanvas.width = cssW * dpr;
    drawCanvas.height = cssH * dpr;
    overlayCanvas.width = cssW * dpr;
    overlayCanvas.height = cssH * dpr;

    drawCanvas.style.width = overlayCanvas.style.width = cssW + 'px';
    drawCanvas.style.height = overlayCanvas.style.height = cssH + 'px';

    drawCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    overlayCtx.setTransform(1, 0, 0, 1, 0, 0);

    drawCtx.fillStyle = 'black';
    drawCtx.fillRect(0, 0, cssW, cssH);
  }

  function cssSize() {
    return {
      w: parseFloat(drawCanvas.style.width) || 800,
      h: parseFloat(drawCanvas.style.height) || 600
    };
  }

  function mirrorLandmarks(landmarks) {
    return landmarks.map(l => ({ x: 1 - l.x, y: l.y, z: l.z ?? 0 }));
  }

  function getSmoothingFactor() {
    return (parseInt(smoothingRange.value) || 30) / 100;
  }

  function updateSmoothed(mirrored) {
    const alpha = getSmoothingFactor();
    if (!smoothedLandmarks) {
      smoothedLandmarks = mirrored.map(p => ({ ...p }));
      return smoothedLandmarks;
    }
    for (let i = 0; i < mirrored.length; i++) {
      smoothedLandmarks[i].x = smoothedLandmarks[i].x * alpha + mirrored[i].x * (1 - alpha);
      smoothedLandmarks[i].y = smoothedLandmarks[i].y * alpha + mirrored[i].y * (1 - alpha);
      smoothedLandmarks[i].z = smoothedLandmarks[i].z * alpha + mirrored[i].z * (1 - alpha);
    }
    return smoothedLandmarks;
  }
  function handleLandmarks(landmarks) {
    const css = cssSize();
    const m = mirrorLandmarks(landmarks);
    const sm = updateSmoothed(m);

    const ix = sm[8].x, iy = sm[8].y;
    const tx = sm[4].x, ty = sm[4].y;
    const cx = ix * css.w, cy = iy * css.h;
    const distPx = Math.hypot((ix - tx) * css.w, (iy - ty) * css.h);
    const pinchThreshPx = Math.min(css.w, css.h) * pinchThresholdNorm;
    const pinching = distPx < pinchThreshPx;

    if (showLandmarks.checked) {
      const dpr = window.devicePixelRatio || 1;
      overlayCtx.beginPath();
      overlayCtx.arc(ix * overlayCanvas.width, iy * overlayCanvas.height, Math.max(4, parseInt(sizeRange.value)/2) * dpr, 0, Math.PI * 2);
      overlayCtx.fillStyle = 'rgba(255,255,255,0.9)';
      overlayCtx.fill();
      overlayCtx.closePath();
    }

    if (pinching) {
      if (!wasPinching) {
        drawCtx.beginPath();
        drawCtx.moveTo(cx, cy);
      }
      drawCtx.strokeStyle = colorPicker.value;
      drawCtx.lineWidth = parseInt(sizeRange.value, 10);
      drawCtx.lineCap = 'round';
      drawCtx.lineJoin = 'round';
      drawCtx.lineTo(cx, cy);
      drawCtx.stroke();
    } else if (wasPinching) {
      drawCtx.closePath();
    }
    wasPinching = pinching;
  }

  const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.6
  });

  hands.onResults(res => {
    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
      for (const lm of res.multiHandLandmarks) {
        const mirrored = mirrorLandmarks(lm);
        if (showLandmarks.checked) {
          drawConnectors(overlayCtx, mirrored, HAND_CONNECTIONS, { color: '#00ffb3', lineWidth: 2 });
          drawLandmarks(overlayCtx, mirrored, { color: '#ffa500', lineWidth: 2 });
        }
      }
      handleLandmarks(res.multiHandLandmarks[0]);
      statusEl.textContent = wasPinching ? 'Drawing...' : 'Hand detected — hover';
    } else {
      statusEl.textContent = 'No hand detected';
      wasPinching = false;
    }
  });
  startCamBtn.addEventListener('click', async () => {
    try {
      cameraInstance = new Camera(video, {
        onFrame: async () => { await hands.send({ image: video }); },
        width: 1280,
        height: 720
      });
      await cameraInstance.start();
      startCamBtn.disabled = true;
      stopCamBtn.disabled = false;
      statusEl.textContent = 'Camera started — pinch to draw';
    } catch (err) {
      statusEl.textContent = (err.name === 'NotAllowedError')
        ? 'Camera permission denied'
        : 'Camera failed: ' + err.message;
    }
  });

  stopCamBtn.addEventListener('click', () => {
    if (cameraInstance) cameraInstance.stop();
    startCamBtn.disabled = false;
    stopCamBtn.disabled = true;
    statusEl.textContent = 'Camera stopped';
  });

  localDrawBtn.addEventListener('click', () => {
    localDraw = !localDraw;
    localDrawBtn.textContent = 'Local Draw: ' + (localDraw ? 'On' : 'Off');
  });

  drawCanvas.addEventListener('pointerdown', e => {
    if (localDraw) {
      const rect = drawCanvas.getBoundingClientRect();
      lastX = e.clientX - rect.left;
      lastY = e.clientY - rect.top;
      isDrawing = true;
    }
  });

  window.addEventListener('pointermove', e => {
    if (localDraw && isDrawing) {
      const rect = drawCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      drawCtx.strokeStyle = colorPicker.value;
      drawCtx.lineWidth = parseInt(sizeRange.value, 10);
      drawCtx.lineCap = 'round';
      drawCtx.beginPath();
      drawCtx.moveTo(lastX, lastY);
      drawCtx.lineTo(x, y);
      drawCtx.stroke();
      lastX = x;
      lastY = y;
    }
  });

  window.addEventListener('pointerup', () => { if (localDraw) isDrawing = false; });

  clearBtn.addEventListener('click', () => {
    const css = cssSize();
    drawCtx.clearRect(0, 0, css.w, css.h);
    drawCtx.fillStyle = 'black';
    drawCtx.fillRect(0, 0, css.w, css.h);
  });

  saveBtn.addEventListener('click', () => {
    const link = document.createElement('a');
    link.download = 'drawing.png';
    link.href = drawCanvas.toDataURL();
    link.click();
  });

  pinchRange.addEventListener('input', () => {
    pinchThresholdNorm = parseInt(pinchRange.value) / 100;
  });

  window.addEventListener('resize', () => {
    const rect = drawCanvas.getBoundingClientRect();
    resizeCanvases(rect.width, rect.height);
  });

  const tutorialOverlay = document.getElementById('tutorialOverlay');
  const dismissTutorial = document.getElementById('dismissTutorial');
  const dontShowTutorial = document.getElementById('dontShowTutorial');

  function tryShowTutorialOnce() {
    if (!localStorage.getItem('hideTutorial')) {
      tutorialOverlay.classList.remove('hidden');
    }
  }

  dismissTutorial.addEventListener('click', () => {
    tutorialOverlay.classList.add('hidden');
  });

  dontShowTutorial.addEventListener('click', () => {
    localStorage.setItem('hideTutorial', '1');
    tutorialOverlay.classList.add('hidden');
  });

  resizeCanvases(800, 600);
  tryShowTutorialOnce();
  </script>
</body>
</html>
